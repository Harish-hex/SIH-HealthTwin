from flask import Flask, request, jsonify
from flask_cors import CORS
from database import db, WaterQualityRecord, PredictionRecord, HealthAlert, HealthWorker, seed_initial_data, save_prediction_record
from model.predict import predict_disease
from sqlalchemy import func
import os

app = Flask(__name__)
CORS(app)

# Database configuration
app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{os.path.join(os.path.dirname(__file__), "health_monitoring.db")}'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Initialize database
db.init_app(app)

# Create tables and seed data
with app.app_context():
    db.create_all()
    seed_initial_data()

@app.route("/")
def home():
    return {"message": "Smart Health Monitoring API with Database is running!", "endpoints": ["/predict", "/records", "/alerts", "/statistics/<state>", "/workers"]}

@app.route("/predict", methods=["POST"])
def predict():
    try:
        data = request.json
        ph = float(data["ph"])
        turbidity = float(data["turbidity"])
        tds = float(data["tds"])
        people_affected = int(data["people_affected_per_5000"])
        
        # Get additional info if provided
        location = data.get("location", "Unknown")
        state = data.get("state", "Unknown")
        district = data.get("district", "Unknown")
        collected_by = data.get("collected_by", "System")

        # Get prediction
        result = predict_disease(ph, turbidity, tds, people_affected)
        
        # Prepare data for database save
        water_data = {
            'ph': ph,
            'turbidity': turbidity,
            'tds': tds,
            'people_affected_per_5000': people_affected
        }
        
        additional_info = {
            'location': location,
            'state': state,
            'district': district,
            'collected_by': collected_by
        }
        
        # Save to database
        saved_record = save_prediction_record(water_data, result, additional_info)
        
        # Add record ID to response
        if saved_record:
            result['record_id'] = saved_record['id']
            result['saved_to_database'] = True
        else:
            result['saved_to_database'] = False
            
        return jsonify(result)

    except Exception as e:
        return jsonify({"error": str(e)}), 400

@app.route("/records", methods=["GET"])
def get_records():
    """Get recent prediction records"""
    try:
        limit = request.args.get('limit', 50, type=int)
        state_filter = request.args.get('state', None)
        
        # Build query
        query = db.session.query(PredictionRecord, WaterQualityRecord)\
            .join(WaterQualityRecord)
        
        # Apply state filter if provided
        if state_filter:
            query = query.filter(WaterQualityRecord.state == state_filter)
        
        # Order and limit
        records = query.order_by(PredictionRecord.timestamp.desc()).limit(limit).all()
        
        result = []
        for pred, water in records:
            result.append({
                'id': pred.id,
                'predicted_disease': pred.predicted_disease,
                'health_alert': pred.health_alert,
                'timestamp': pred.timestamp.isoformat(),
                'water_quality': {
                    'ph': water.ph,
                    'turbidity': water.turbidity,
                    'tds': water.tds,
                    'people_affected': water.people_affected_per_5000,
                    'location': water.location,
                    'state': water.state,
                    'district': water.district,
                    'collected_by': water.collected_by
                }
            })
        
        return jsonify(result)
    except Exception as e:
        return jsonify({"error": str(e)}), 400

@app.route("/alerts", methods=["GET"])
def get_alerts():
    """Get active health alerts"""
    try:
        status_filter = request.args.get('status', 'ACTIVE')
        state_filter = request.args.get('state', None)
        
        # Build query
        query = db.session.query(HealthAlert, PredictionRecord, WaterQualityRecord)\
            .join(PredictionRecord)\
            .join(WaterQualityRecord)\
            .filter(HealthAlert.status == status_filter)
        
        # Apply state filter if provided
        if state_filter:
            query = query.filter(WaterQualityRecord.state == state_filter)
        
        alerts = query.order_by(HealthAlert.created_at.desc()).all()
        
        result = []
        for alert, pred, water in alerts:
            result.append({
                'id': alert.id,
                'alert_level': alert.alert_level,
                'status': alert.status,
                'created_at': alert.created_at.isoformat(),
                'notes': alert.notes,
                'prediction': {
                    'disease': pred.predicted_disease,
                    'health_alert': pred.health_alert
                },
                'location': {
                    'state': water.state,
                    'district': water.district,
                    'location': water.location
                },
                'assigned_worker': alert.assigned_worker.to_dict() if alert.assigned_worker else None
            })
        
        return jsonify(result)
    except Exception as e:
        return jsonify({"error": str(e)}), 400

@app.route("/statistics/<state>", methods=["GET"])
def get_state_statistics(state):
    """Get health statistics for a state"""
    try:
        # Count of records by disease type
        stats = db.session.query(
            PredictionRecord.predicted_disease,
            func.count(PredictionRecord.id).label('count'),
            func.avg(WaterQualityRecord.ph).label('avg_ph'),
            func.avg(WaterQualityRecord.turbidity).label('avg_turbidity'),
            func.avg(WaterQualityRecord.tds).label('avg_tds')
        ).join(WaterQualityRecord)\
         .filter(WaterQualityRecord.state == state)\
         .group_by(PredictionRecord.predicted_disease)\
         .all()
        
        result = []
        for stat in stats:
            result.append({
                'disease': stat.predicted_disease,
                'count': stat.count,
                'avg_ph': round(stat.avg_ph, 2) if stat.avg_ph else None,
                'avg_turbidity': round(stat.avg_turbidity, 2) if stat.avg_turbidity else None,
                'avg_tds': round(stat.avg_tds, 2) if stat.avg_tds else None
            })
        
        return jsonify({
            'state': state,
            'statistics': result,
            'total_records': sum(stat.count for stat in stats)
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 400

@app.route("/workers", methods=["GET"])
def get_health_workers():
    """Get all health workers"""
    try:
        state_filter = request.args.get('state', None)
        
        query = HealthWorker.query.filter(HealthWorker.is_active == True)
        
        if state_filter:
            query = query.filter(HealthWorker.state == state_filter)
        
        workers = query.all()
        result = [worker.to_dict() for worker in workers]
        
        return jsonify(result)
    except Exception as e:
        return jsonify({"error": str(e)}), 400

@app.route("/alerts/<int:alert_id>/assign", methods=["PUT"])
def assign_alert(alert_id):
    """Assign an alert to a health worker"""
    try:
        data = request.json
        worker_id = data.get('worker_id')
        notes = data.get('notes', '')
        
        alert = HealthAlert.query.get_or_404(alert_id)
        alert.assigned_to = worker_id
        alert.notes = notes
        alert.status = 'INVESTIGATING'
        
        db.session.commit()
        
        return jsonify(alert.to_dict())
    except Exception as e:
        return jsonify({"error": str(e)}), 400

@app.route("/alerts/<int:alert_id>/resolve", methods=["PUT"])
def resolve_alert(alert_id):
    """Mark an alert as resolved"""
    try:
        data = request.json
        notes = data.get('notes', '')
        
        alert = HealthAlert.query.get_or_404(alert_id)
        alert.status = 'RESOLVED'
        alert.notes = notes
        
        db.session.commit()
        
        return jsonify(alert.to_dict())
    except Exception as e:
        return jsonify({"error": str(e)}), 400

@app.route("/dashboard", methods=["GET"])
def get_dashboard_data():
    """Get comprehensive dashboard data"""
    try:
        # Summary statistics
        total_records = PredictionRecord.query.count()
        active_alerts = HealthAlert.query.filter(HealthAlert.status == 'ACTIVE').count()
        total_workers = HealthWorker.query.filter(HealthWorker.is_active == True).count()
        
        # Disease breakdown
        disease_stats = db.session.query(
            PredictionRecord.predicted_disease,
            func.count(PredictionRecord.id).label('count')
        ).group_by(PredictionRecord.predicted_disease).all()
        
        # State-wise breakdown
        state_stats = db.session.query(
            WaterQualityRecord.state,
            func.count(PredictionRecord.id).label('total_predictions'),
            func.sum(func.sum(func.case([(PredictionRecord.predicted_disease != "None", 1)], else_=0))).label('disease_predictions')
        ).join(PredictionRecord)\
         .group_by(WaterQualityRecord.state)\
         .all()
        
        return jsonify({
            'summary': {
                'total_records': total_records,
                'active_alerts': active_alerts,
                'total_workers': total_workers
            },
            'disease_breakdown': [{'disease': d.predicted_disease, 'count': d.count} for d in disease_stats],
            'state_breakdown': [{'state': s.state, 'total_predictions': s.total_predictions, 'disease_predictions': s.disease_predictions} for s in state_stats]
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 400

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=5001, debug=True)
